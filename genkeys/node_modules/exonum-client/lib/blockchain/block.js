'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.verifyBlock = verifyBlock;

var _helpers = require('../helpers');

var _primitive = require('../types/primitive');

var primitive = _interopRequireWildcard(_primitive);

var _generic = require('../types/generic');

var _message = require('../types/message');

var _validate = require('../types/validate');

var _crypto = require('../crypto');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var PROTOCOL_VERSION = 0;
var CORE_SERVICE_ID = 0;
var PRECOMMIT_MESSAGE_ID = 4;
var Block = (0, _generic.newType)({
    size: 112,
    fields: {
        schema_version: { type: primitive.Uint16, size: 2, from: 0, to: 2 },
        proposer_id: { type: primitive.Uint16, size: 2, from: 2, to: 4 },
        height: { type: primitive.Uint64, size: 8, from: 4, to: 12 },
        tx_count: { type: primitive.Uint32, size: 4, from: 12, to: 16 },
        prev_hash: { type: primitive.Hash, size: 32, from: 16, to: 48 },
        tx_hash: { type: primitive.Hash, size: 32, from: 48, to: 80 },
        state_hash: { type: primitive.Hash, size: 32, from: 80, to: 112 }
    }
});
var SystemTime = (0, _generic.newType)({
    size: 12,
    fields: {
        secs: { type: primitive.Uint64, size: 8, from: 0, to: 8 },
        nanos: { type: primitive.Uint32, size: 4, from: 8, to: 12 }
    }
});

/**
 * Validate block and each precommit in block
 * @param {Object} data
 * @param {Array} validators
 * @param {number} networkId
 * @return {boolean}
 */
function verifyBlock(data, validators, networkId) {
    if ((0, _helpers.isObject)(data) === false) {
        return false;
    } else if ((0, _helpers.isObject)(data.block) === false) {
        return false;
    } else if (Array.isArray(data.precommits) === false) {
        return false;
    } else if (Array.isArray(validators) === false) {
        return false;
    }

    for (var i = 0; i < validators.length; i++) {
        if (!(0, _validate.validateHexadecimal)(validators[i])) {
            return false;
        }
    }

    try {
        var blockHash = (0, _crypto.hash)(data.block, Block);
    } catch (error) {
        return false;
    }

    if (typeof networkId !== 'number' || networkId < 0 || networkId > 255) {
        return false;
    }

    var Precommit = (0, _message.newMessage)({
        size: 90,
        network_id: networkId,
        protocol_version: PROTOCOL_VERSION,
        message_id: PRECOMMIT_MESSAGE_ID,
        service_id: CORE_SERVICE_ID,
        fields: {
            validator: { type: primitive.Uint16, size: 2, from: 0, to: 2 },
            height: { type: primitive.Uint64, size: 8, from: 2, to: 10 },
            round: { type: primitive.Uint32, size: 4, from: 10, to: 14 },
            propose_hash: { type: primitive.Hash, size: 32, from: 14, to: 46 },
            block_hash: { type: primitive.Hash, size: 32, from: 46, to: 78 },
            time: { type: SystemTime, size: 12, from: 78, to: 90 }
        }
    });

    var validatorsTotalNumber = validators.length;
    var uniqueValidators = [];
    var round;

    for (i = 0; i < data.precommits.length; i++) {
        var precommit = data.precommits[i];

        if ((0, _helpers.isObject)(precommit.body) === false) {
            return false;
        }

        if (!(0, _validate.validateHexadecimal)(precommit.signature, 64)) {
            return false;
        }

        if (precommit.body.validator >= validatorsTotalNumber) {
            // validator does not exist
            return false;
        }

        if (uniqueValidators.indexOf(precommit.body.validator) === -1) {
            uniqueValidators.push(precommit.body.validator);
        }

        if (precommit.network_id !== networkId || precommit.protocol_version !== PROTOCOL_VERSION || precommit.service_id !== CORE_SERVICE_ID || precommit.message_id !== PRECOMMIT_MESSAGE_ID) {
            return false;
        }

        if (precommit.body.height !== data.block.height) {
            // wrong height of block in precommit
            return false;
        } else if (precommit.body.block_hash !== blockHash) {
            // wrong hash of block in precommit
            return false;
        }

        if (round === undefined) {
            round = precommit.body.round;
        } else if (precommit.body.round !== round) {
            // wrong round in precommit
            return false;
        }

        var publicKey = validators[precommit.body.validator];

        if (!(0, _crypto.verifySignature)(precommit.signature, publicKey, precommit.body, Precommit)) {
            return false;
        }
    }

    if (uniqueValidators.length <= validatorsTotalNumber * 2 / 3) {
        // not enough precommits from unique validators
        return false;
    }

    return true;
}
